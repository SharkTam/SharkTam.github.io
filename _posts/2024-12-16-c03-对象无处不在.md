---
layout: post
title: c03 对象无处不在
date: 2024-12-16 10:34 +0000
description: 
image: 
category: [Java, 《On Java base》]
tags: 
published: true
math: true
---

## 1. 通过引用操作对象

所有编程语言都在内存中处理各种元素，程序员必须小心对待这种内存操作。Java 中将一切都视为对象，从而简化了这个问题。虽然说的是 “将一切都视为对象”，但你实际操作的是该对象（电视）的引用（遥控器），遥控器不依赖于电视而存在，同样，引用也未必会关联某个对象。例如，`String s;` 只是创建了一个引用，并未为其分配对象，需要将该引用连接到某个对象上去才能对引用进行操作，否则编译器会报错。

一般的做法是在创建引用时就进行初始化，将其连接到某个对象上去。例如 `String s = "abcd";`，该语句使用了 Java 的一个特性，即字符串 （String）可以用带引号的文本进行初始化。而对于其他类型的对象而言，需要使用一种更为通用的初始化方式，即使用 new 关键字创建对象。new 关键字表达的意思是 “我要一个这种类型的对象”。所以，上述语句也可用 `String s = new String("abcd");` 替代。

在 Java 中对象的引用一般存储在栈中，对象本身一般存储在堆中（因为栈中对象需要指明生命周期，而堆中没有这个要求）。

### 1.1 特殊情况：基本类型

Java 中有 8 中基本类型，对于这 8 中基本类型，无需使用 new 关键字来创建对象，因为 new 关键字是在堆上创建对象，这就意味着哪怕是创建一些简单的变量也不会很高效。对于基本类型 Java 使用了与 C 以及 C++ 相同的实现机制，直接创建一个 “自动变量”（automatic variable）注意**不是引用**，也就是说，该变量会直接在栈上保存它的值，因此运行效率也比较高。

Java 中定义了每一种基本类型所占用的空间大小，即使是在不同机器上，这些类型所占用的空间也是保持一致的。

此外，Java 还为基本类型提供了对应的 **“包装类”（wrapper class）**，通过包装类可以将基本类型呈现为对上的非原始对象，例如：
```java
char c = 'x';
Character ch = new Character(c);
---
Character ch = new Character('x');
```
与 “包装类” 伴生的还有一个 **“自动装箱”（autoboxing）**机制，基本类型对象可以自动转化为包装类对象，例如：
```java
Character ch = 'x'; // 基本类型对象 ==> 包装类对象
char c = ch;        // 包装类对象 ==> 基本类型对象
```
**两个特殊的包装类对象——BigInteger 和 BigDecimal**，虽然这两个类为包装类，但它们没有对应的基本类型。这两个类一般用于高精度计算，BigInteger 可以支持任意精度的整数，BigDecimal 可以支持任意精度的定点数。

### 1.2 Java 中的数组

在 Java 中，当你创建一个用于放置对象的数组时，实际上数组里包含的是引用，而这些引用会被自动初始化为一个特殊的值：null。Java 会认为一个值为 null 的引用没有指向任何对象，所以当你操作引用之前，需要确保将其指向了某个对象。如果你试图操作一个值为 null 的引用，系统会返回一个运行时错误。

此外，你也可以创建一个放置基本类型的数组。编译器会确保对该数据进行初始化，并将数组元素的值置为 0。

## 2. Java 中无需销毁对象

大多数过程式编程语言都具有**作用域**（scope）的概念。作用域会决定其范围内定义的变量名的可见性和生命周期。C、C++ 以及 Java 的作用域范围都是通过花括号 `{}` 来定义的。在作用域中定义的变量只在该作用域的范围内可见。注意，虽然下面的代码对于 C 和 C++ 而言是合法的，但在 Java 中不能这样使用：
```c
{
  int x = 12;
  {
    int x = 96; // Java 中语法错误，C、C++ 中无误
  }
}
```
类似 C 和 C++ 那样在外围的作用域中 “隐藏” 变量的方式在 Java 中是不被允许的。

### 2.1 对象的作用域

Java 对象的生命周期和基本类型的有所不同。当你使用 new 创建一个对象时，该对象在其作用域结束后依然存在。垃圾收集器会监视所有通过 new 关键字创建的对象，并及时发现哪些对象不再被引用，然后它会释放这些对象所占用的内存，使得这些内存可以用于其他新对象。
